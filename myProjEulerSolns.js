//----------------------------------------------------------------------
console.log();
console.log(' ===== FIRST 30 PROJECT EULER QUESTIONS ===== ');
console.log();
//----------------------------------------------------------------------




console.log(' ===== 01: MULTIPLES OF 3 AND 5 ===== ');
//----------------------------------------------------------------------------+
// Multiples of 3 and 5                                                       +
// Problem 1                                                                  +
// If we list all the natural numbers below 10 that are multiples of 3 or 5,  +
// we get 3, 5, 6 and 9. The sum of these multiples is 23.                    +
//                                                                            +
// Find the sum of all the multiples of 3 or 5 below 1000.                    +
//----------------------------------------------------------------------------+
var multiplesOf3And5 = function(num) {
    var result = 0;
    // I will iterate from i = 0 to i 999 and add all i's that are either multiples multiples of 3 and/or 5 to result.
    for (var i = 0; i < num; i++) {
        if (i % 3 === 0 || i % 5 === 0) {
            result += i;
        }
    }
    return result;
};
// console.log(multiplesOf3And5(1000)); // 233168
console.log();


console.log(' ===== 02: EVEN FIBONACCI NUMBERS ===== ');
//----------------------------------------------------------------------------+
// Even Fibonacci numbers                                                     +
// Problem 2                                                                  +
// Each new term in the Fibonacci sequence is generated by adding the         +
// previous two terms. By starting with 1 and 2, the first 10 terms will be:  +
//                                                                            +
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...                                     +
//                                                                            +
// By considering the terms in the Fibonacci sequence whose values do not     +
// exceed four million, find the sum of the even-valued terms.                +
//----------------------------------------------------------------------------+
var isEven = function(num) {
    return num % 2 === 0;
};
//----------------------------------------------------------------------
var isInFibonacci = function(num) {
    var fibArr = [1, 2];
    while (fibArr[fibArr.length - 1] <= num) {
        fibArr.push((fibArr[fibArr.length - 1]) + (fibArr[fibArr.length - 2]));
    }
    return fibArr.includes(num);
};
//----------------------------------------------------------------------
var sumOfEvenFibonacci = function(num) {
    // I will create the helper functions isEven and isInFibonacci to test all i's from 1 up to but not including num, and then adding those that are even and Fibonacci numbers to result.
    var result = 0;
    for (var i = 1; i < num; i++) {
        if (isEven(i) && isInFibonacci(i)) {
            result += i;
        }
    }
    return result;
};
// console.log(sumOfEvenFibonacci(4000000)); // 4613732
console.log();


console.log(' ===== 03: LARGEST PRIME FACTOR ===== ');
//-----------------------------------------------------------------------------+
// Largest prime factor                                                        +
// Problem 3                                                                   +
// The prime factors of 13195 are 5, 7, 13 and 29.                             +
//                                                                             +
// What is the largest prime factor of the number 600851475143 ?               +
//-----------------------------------------------------------------------------+
var isPrime = function(num) {
    if (num === 2) {
        return true;
    }
    for (var i = 2; i < num; i++) {
        if (num % i === 0) {
            return false;
        }
    }
    return true;
};
//----------------------------------------------------------------------
var isFactor = function(numParent, numChild) {
    return numParent % numChild === 0;
};
//----------------------------------------------------------------------
var largestPrimeFactor = function(num) {
    // Because num can only be an integral multiple of its factors, I will be iterating from i = 1 (equal to num) through i = (num + 1) / 2 because num is odd. This is roughly half of num. I will then check if k = num / i is an integer. If it is then it must be a factor of num.(I had written the isFactor function to check for this but i now realize it would be redundant to invoke it). I will then check if k is prime and then return it. This should return the largest factro that is also a prime.
    for (var i = 1; i < (num + 1) / 2; i++) {
        var k = num / i;
        if (num % i === 0 && isPrime(k)) {
            return k;
        }
    }
};
// console.log(largestPrimeFactor(600851475143)); // 6857
console.log();


console.log(' ===== 04: LARGEST PALINDROME PRODUCT ===== ');
//-----------------------------------------------------------------------------+
// Largest palindrome product                                                  +
// Problem 4                                                                   +
// A palindromic number reads the same both ways. The largest palindrome       +
//  made from the product of two 2-digit numbers is 9009 = 91 × 99.            +
//                                                                             +
// Find the largest palindrome made from the product of two 3-digit numbers.   +
//-----------------------------------------------------------------------------+
var isPalindrome = function(str) {
    str = str.toString();
    var strLength = str.length;
    var result = true;
    for (var i = 0; i < strLength; i++) {
        if (str[i] !== str[strLength - (1 + i)]) {
            return false;
        }
    }
    return result;
};
//----------------------------------------------------------------------
var largestPalindromeProduct = function(biggerDigit, smallerDigit) {
    // I will be using the isPalindrome helper function above to solve this problem. So the smallest n-digit number is '1' + 'n-1 zeros' and the largest is '9' times n. Thus the range of 3 by 3 didgit numbers would be from 999 - 100. I will iterate for a general 'biggerDigit' by 'smallerDigit' below. I will then form a combination from the range, checking each product to see if it is a palindrome. I will push each palindrome into the result array until I have iterated through the entire range, and then return the max number from the result array.
    var result = [];
    for (var i = Number('9'.repeat(biggerDigit)); i >= Number('1' + '0'.repeat(biggerDigit - 1)); i--) {
        for (var j = Number('9'.repeat(smallerDigit)); j >= Number('1' + '0'.repeat(smallerDigit - 1)); j--) {
            if (isPalindrome(i * j)) {
                result.push(i * j);
            }
        }
    }
    return Math.max(...result);
};
// console.log(largestPalindromeProduct(3, 3)); // 906609
console.log();


console.log(' ===== 05: SMALLEST MULTIPLE ===== ');
//-----------------------------------------------------------------------------+
// Smallest multiple                                                           +
// Problem 5                                                                   +
// 2520 is the smallest number that can be divided by each of the numbers      +
// from 1 to 10 without any remainder.                                         +
//                                                                             +
// What is the smallest positive number that is evenly divisible by all of     +
// the numbers from 1 to 20?                                                   +
//-----------------------------------------------------------------------------+
var smallestMultiple = function(num) {
    // So the smallest positive multiple of all numbers from 1 to n has to be a multiple of n. Hence in this problem I will be iterating from n in increaments of n until I hit the first multple of n that is also a multiple of all the number 1....n.
    var result = num; // I will increase result by n after each iteration.
    var timesToRun = num; // the loop willend when timesToRun = 0;
    while (timesToRun > 0) {
        for (var j = 2; j <= num; j++) {
            // I am skipping the number 1 above for obvious reasons.
            if (result % j === 0 && timesToRun === 0) {
                return result; // loop ends if timesToRun = 0.
            } else if (result % j === 0) {
                timesToRun -= 1;
            } else {
                timesToRun = num;
                result += num;
            }
        }
    }

    return result;
};
// console.log(smallestMultiple(20)); // 232792560
console.log();


console.log(' ===== 06: SUM SQUARE DIFFERENCE ===== ');
//-----------------------------------------------------------------------------+
// Sum square difference                                                       +
// Problem 6                                                                   +
// The sum of the squares of the first ten natural numbers is,                 +
// 1 ** 2 + 2 ** 2 + ... + 10 ** 2 = 385                                       +
// The square of the sum of the first ten natural numbers is,                  +
// (1 + 2 + ... + 10)2 = 552 = 3025                                            +
// Hence the difference between the sum of the squares of the first ten        +
// natural numbers and the square of the sum is 3025 − 385 = 2640.             +
//                                                                             +
// Find the difference between the sum of the squares of the first one         +
// hundred natural numbers and the square of the sum.                          +
//-----------------------------------------------------------------------------+
var sumSquareDifference = function(num) {
    // I will create an array to hold the first num natural numbers.
    var numArr = [];
    for (var i = 1; i <= num; i++) {
        numArr.push(i);
    }
    // I will then map numArr to its sqaures as numArrSq.
    var numArrSq = numArr.map(function(x) {
            return x ** 2;
        })
        // then I will square the sum of all the elements of numArr, and the subtract the sum of all the lements of numArrSq from it.
    var sum = numArr.reduce(function(a, b) { return a + b; });
    var squareSum = numArrSq.reduce(function(a, b) { return a + b; });
    return sum ** 2 - squareSum;
};
// console.log(sumSquareDifference(100)); // 25164150
console.log();


console.log(' ===== 07: 10001ST PRIME ===== ');
//-----------------------------------------------------------------------------+
// 10001st prime                                                               +
// Problem 7                                                                   +
// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can      +
// see that the 6th prime is 13.                                               +
//                                                                             +
// What is the 10 001st prime number?                                          +
//-----------------------------------------------------------------------------+
var nthPrime = function(num) {
    // I will be reusing the isPrime function from problem 3 in here. 
    // I will start with the first prime number as 'starter' and set my counter to zero, and run starter through the isPrime function to trigger the while loop until my counter = num (10 001st in this problem).
    var starter = 2;
    var counter = 0
    while (counter < num) {
        if (isPrime(starter)) {
            counter += 1
        }
        starter += 1
    }

    return starter - 1;
};
// console.log(nthPrime(10001)); // 104743
console.log();


console.log(' ===== 08: LARGEST PRODUCT IN SERIES ===== ');
//-----------------------------------------------------------------------------+
// Largest product in a series                                                 +
// Problem 8                                                                   +
// The four adjacent digits in the 1000-digit number that have the             +
//greatest product are 9 × 9 × 8 × 9 = 5832.                                   +
//                                                                             +
// 73167176531330624919225119674426574742355349194934                          +
// 96983520312774506326239578318016984801869478851843                          +
// 85861560789112949495459501737958331952853208805511                          +
// 12540698747158523863050715693290963295227443043557                          +
// 66896648950445244523161731856403098711121722383113                          +
// 62229893423380308135336276614282806444486645238749                          +
// 30358907296290491560440772390713810515859307960866                          +
// 70172427121883998797908792274921901699720888093776                          +
// 65727333001053367881220235421809751254540594752243                          +
// 52584907711670556013604839586446706324415722155397                          +
// 53697817977846174064955149290862569321978468622482                          +
// 83972241375657056057490261407972968652414535100474                          +
// 82166370484403199890008895243450658541227588666881                          +
// 16427171479924442928230863465674813919123162824586                          +
// 17866458359124566529476545682848912883142607690042                          +
// 24219022671055626321111109370544217506941658960408                          +
// 07198403850962455444362981230987879927244284909188                          +
// 84580156166097919133875499200524063689912560717606                          +
// 05886116467109405077541002256983155200055935729725                          +
// 71636269561882670428252483600823257530420752963450                          +
//                                                                             +
// Find the thirteen adjacent digits in the 1000-digit number that have        +
// the greatest product. What is the value of this product?                    +
//-----------------------------------------------------------------------------+
var crazyNum = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450'
var largestProdiNASeries = function(string, num) {
    // I copied the given numbers as a string names 'crazynum' above. I will convert that into an array and then map them to their numerical equivalents, as strArr.
    var result = undefined;
    var stringArr = string.split('');
    var strArr = stringArr.map(function(lett) { return Number(lett); })
        // I will then loop through the strArr, slicing through the required number of adjacent numbers, and then reducing those values. I will then compare each reduce value to 'result' and keep the greater of the two. At the end of iteration, result should be the greatest value.
    for (var i = 0; i < strArr.length; i++) {
        currArr = strArr.slice(i, i + num);
        var tester = currArr.reduce(function(a, b) { return a * b; })

        if (tester > result || result === undefined) {
            result = tester;
        }
    }

    return result;
};
// console.log(largestProdiNASeries(crazyNum, 13)); // 23514624000
console.log();


console.log(' ===== 09: SPECIAL PYTHAGOREAN TRIPLET ===== ');
//-----------------------------------------------------------------------------+
// Special Pythagorean triplet                                                 +
// Problem 9                                                                   +
// A Pythagorean triplet is a set of three natural numbers, a < b < c,         +
// for which,                                                                  +
//                                                                             +
// a ** 2 + b ** 2 = c ** 2                                                    +
// For example, 3 ** 2 + 4 ** 2 = 9 + 16 = 25 = 5 ** 2.                        +
//                                                                             +
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.    +
// Find the product abc.                                                       +
//-----------------------------------------------------------------------------+
var specialPythagoreanTriplet = function(upperRange, targetNum) {
    // I'll set any of a, b, c, to be less than upperRange that should reasonably
    // contain the range of numbers required to reach the targetNum. In the 
    // absence of an upperRange, I will make an educated guess of the upperRange that should reasonably solve the problem. What I do know for sure is that that value is less than targetNum, and possbily much smaller than it. A generous value for upperRange would be half of targetNum, although a better value can be chosen if more thought is put into finding the perfect threshold number. I will be using targetNum / 2 = 1000 / 2 = 500 in my calculation below.
    var resultArr = [];
    for (var a = 1; a < upperRange; a++) {
        for (var b = 1; b < upperRange; b++) {
            for (var c = 1; c < upperRange; c++) {
                if (a ** 2 + b ** 2 === c ** 2 && a + b + c === targetNum) {
                    return a * b * c;
                    // I tried to find out what values a, b, c took to reach the targetNum
                    // resultArr.push(a, b, c); 
                    // return resultArr;
                }
            }
        }
    }
    // return 'Sorry, triplet does not exist'; // in case targetNum is not reached
};
// console.log(specialPythagoreanTriplet(500, 1000)); // 31875000
console.log();


console.log(' ===== 10: SUMMATION OF PRIMES ===== ');
//-----------------------------------------------------------------------------+
// Summation of primes                                                         +
// Problem 10                                                                  +
// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.                       +
//                                                                             +
// Find the sum of all the primes below two million.                           +
//-----------------------------------------------------------------------------+
var summationOfPrimes = function(num) {
    // I'll invoke the isPrime function defined earlier in problem 3.
    // I'll also be starting my result array with the value of 2, adding every subsequent prime number to result. And because 2 is the only even prime number I will be iterating only over odd numbers.
    var result = 2
    for (var i = 3; i < num; i += 2) {
        if (isPrime(i)) {
            result += i;
        }
    }
    return result;
};
// console.log(summationOfPrimes(2000000)); // 142913828922
console.log();


console.log(' ===== 11: LARGEST PRODUCT IN A GRID ===== ');
//-----------------------------------------------------------------------------+
// Largest product in a grid                                                   +
// Problem 11                                                                  +
// In the 20×20 grid below, four numbers along a diagonal line have been       +
// marked in red.                                                              +
//                         +                                                   +
// 08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08                 +
// 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00                 +
// 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65                 +
// 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91                 +
// 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80                 +
// 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50                 +
// 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 +               +
// 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21                 +
// 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72                 +
// 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95                 +
// 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92                 +
// 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57                 +
// 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58                 +
// 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40                 +
// 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66                 +
// 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69                 +
// 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36                 +
// 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16                 +
// 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54                 +
// 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48                 +
//                                                                             +
// The product of these numbers is 26 × 63 × 78 × 14 = 1788696.                +
//                                                                             +
// What is the greatest product of four adjacent numbers in the same           +
// direction (up, down, left, right, or diagonally) in the 20×20 grid?         +
//-----------------------------------------------------------------------------+
var rawString = '08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48';
var rawArr = rawString.split(' ').map(function(str) { return Number(str); });
var bigArr = [];
while (bigArr.length <= 20) {
    var smallArr = [];
    for (var i = 0; i < 20; i++) {
        smallArr.push(rawArr.shift());
    }
    bigArr.push(smallArr);
}
//----------------------------------------------------------------------
var largestProdiNAGrid = function(arr) {
    // first, I want to create a 20 * 20 matrix from the grid and name it bigArr, created above to help in solving this.
    // And then assuming all the numbers are positive I will set a var 'result' to equal zero. 
    // Because products are commutative, I will only be iterating from left to right, top to bottom, NW to SE, and NE to SW from index zero to index 17 which should cover index zero to 19, thus touching all indices available.
    // Then at each point or number in the grid (represented by i,j) I will slice 4 places, reduce the product of the 4 numbers and set it to 'result' if it is greater than 'result' until I have touched every point of the grid. I will then return 'result' as the greatest product.
    var result = -Infinity;

    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr[i].length; j++) {
            // going from left to right 
            if (j < arr[i].length - 3) {
                var holder = arr[i][j] * arr[i][j + 1] * arr[i][j + 2] * arr[i][j + 3];
                if (holder > result) {
                    result = holder;
                }
            }
            //going from top to bottom
            if (i < arr[i].length - 3) {
                holder = arr[i][j] * arr[i + 1][j] * arr[i + 2][j] * arr[i + 3][j];
                if (holder > result) {
                    result = holder;
                }
            }
            // going from  NW to SE
            if (j < arr[i].length - 3 && i < arr.length - 3) {
                holder = arr[i][j] * arr[i + 1][j + 1] * arr[i + 2][j + 2] * arr[i + 3][j + 3];
                if (holder > result) {
                    result = holder;
                }
            }
            // going from NE to SW
            if ((i < arr.length - 3) && (j > 2)) {
                holder = arr[i][j] * arr[i + 1][j - 1] * arr[i + 2][j - 2] * arr[i + 3][j - 3];
                if (holder > result) {
                    result = holder;
                }
            }

        }
    }

    return result;
};
// console.log(largestProdiNAGrid(bigArr)); // 70600674
console.log();


console.log(' ===== 12: HIGHLY DIVISBLE TRIANGULAR NUMBER ===== ');
//-----------------------------------------------------------------------------+
// Highly divisible triangular number                                          +
// Problem 12                                                                  +
// The sequence of triangle numbers is generated by adding the natural         +
// numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:                                                  +
//                                                                             +
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...                                    +
//                                                                             +
// Let us list the factors of the first seven triangle numbers:                +
//                                                                             +
//  1: 1                                                                       +
//  3: 1,3                                                                     +
//  6: 1,2,3,6                                                                 +
// 10: 1,2,5,10                                                                +
// 15: 1,3,5,15                                                                +
// 21: 1,3,7,21                                                                +
// 28: 1,2,4,7,14,28                                                           +
// We can see that 28 is the first triangle number to have over five divisors. +
//                                                                             +
// What is the value of the first triangle number to have over five            +
// hundred divisors?                                                           +
//-----------------------------------------------------------------------------+
var factorsOf = function(num) {
    var factArr = [];
    for (var i = 1; i <= Math.ceil(num / 2); i++) {
        if (num % i === 0) {
            factArr.push(i);
        }
    }
    return factArr;
};
//----------------------------------------------------------------------
var nthTriangularNum = function(num) {
    var nextTriangNum = 0;
    var k = 0;
    while (k <= num) {
        nextTriangNum += k;
        k++;
    }
    return nextTriangNum;
};
//----------------------------------------------------------------------
var highlyDivTriangularNum = function(numReq) {
    // I will create two helper functions factorsOf and nthTriangularNum to help with this problem. Making an educated but excessively generous guess, I'd say that no number below 500 can have over 500 factors. The closest Triangular number to this value is 496; the 31st Triangular number. So I will be starting my iteration from 31. I will find the ith Triangular number, check its number of factors to see if is greater than numReq, and return the value of the ith Triangular number.
    var i = 31;
    while (true) {
        var nthTriang = nthTriangularNum(i)
        var checkLength = factorsOf(nthTriang).length;
        if (checkLength > numReq) {
            return nthTriang;
        }
        i += 1;
    }
};
// console.log(highlyDivTriangularNum(501)); // 76576500
console.log();


console.log(' ===== 13: LARGE SUM ===== ');
// //-----------------------------------------------------------------------------+
// Large sum                                                                   +
// Problem 13                                                                  +
// Work out the first ten digits of the sum of the following                   +
// one-hundred  50-digit numbers.                                              +
//-----------------------------------------------------------------------------+
var lottANums = [37107287533902102798797998220837590246510135740250, 46376937677490009712648124896970078050417018260538, 74324986199524741059474233309513058123726617309629, 91942213363574161572522430563301811072406154908250, 23067588207539346171171980310421047513778063246676,
    89261670696623633820136378418383684178734361726757,
    28112879812849979408065481931592621691275889832738,
    44274228917432520321923589422876796487670272189318,
    47451445736001306439091167216856844588711603153276,
    70386486105843025439939619828917593665686757934951,
    62176457141856560629502157223196586755079324193331,
    64906352462741904929101432445813822663347944758178,
    92575867718337217661963751590579239728245598838407,
    58203565325359399008402633568948830189458628227828,
    80181199384826282014278194139940567587151170094390,
    35398664372827112653829987240784473053190104293586,
    86515506006295864861532075273371959191420517255829,
    71693888707715466499115593487603532921714970056938,
    54370070576826684624621495650076471787294438377604,
    53282654108756828443191190634694037855217779295145,
    36123272525000296071075082563815656710885258350721,
    45876576172410976447339110607218265236877223636045,
    17423706905851860660448207621209813287860733969412,
    81142660418086830619328460811191061556940512689692,
    51934325451728388641918047049293215058642563049483,
    62467221648435076201727918039944693004732956340691,
    15732444386908125794514089057706229429197107928209,
    55037687525678773091862540744969844508330393682126,
    18336384825330154686196124348767681297534375946515,
    80386287592878490201521685554828717201219257766954,
    78182833757993103614740356856449095527097864797581,
    16726320100436897842553539920931837441497806860984,
    48403098129077791799088218795327364475675590848030,
    87086987551392711854517078544161852424320693150332,
    59959406895756536782107074926966537676326235447210,
    69793950679652694742597709739166693763042633987085,
    41052684708299085211399427365734116182760315001271,
    65378607361501080857009149939512557028198746004375,
    35829035317434717326932123578154982629742552737307,
    94953759765105305946966067683156574377167401875275,
    88902802571733229619176668713819931811048770190271,
    25267680276078003013678680992525463401061632866526,
    36270218540497705585629946580636237993140746255962,
    24074486908231174977792365466257246923322810917141,
    91430288197103288597806669760892938638285025333403,
    34413065578016127815921815005561868836468420090470,
    23053081172816430487623791969842487255036638784583,
    11487696932154902810424020138335124462181441773470,
    63783299490636259666498587618221225225512486764533,
    67720186971698544312419572409913959008952310058822,
    95548255300263520781532296796249481641953868218774,
    76085327132285723110424803456124867697064507995236,
    37774242535411291684276865538926205024910326572967,
    23701913275725675285653248258265463092207058596522,
    29798860272258331913126375147341994889534765745501,
    18495701454879288984856827726077713721403798879715,
    38298203783031473527721580348144513491373226651381,
    34829543829199918180278916522431027392251122869539,
    40957953066405232632538044100059654939159879593635,
    29746152185502371307642255121183693803580388584903,
    41698116222072977186158236678424689157993532961922,
    62467957194401269043877107275048102390895523597457,
    23189706772547915061505504953922979530901129967519,
    86188088225875314529584099251203829009407770775672,
    11306739708304724483816533873502340845647058077308,
    82959174767140363198008187129011875491310547126581,
    97623331044818386269515456334926366572897563400500,
    42846280183517070527831839425882145521227251250327,
    55121603546981200581762165212827652751691296897789,
    32238195734329339946437501907836945765883352399886,
    75506164965184775180738168837861091527357929701337,
    62177842752192623401942399639168044983993173312731,
    32924185707147349566916674687634660915035914677504,
    99518671430235219628894890102423325116913619626622,
    73267460800591547471830798392868535206946944540724,
    76841822524674417161514036427982273348055556214818,
    97142617910342598647204516893989422179826088076852,
    87783646182799346313767754307809363333018982642090,
    10848802521674670883215120185883543223812876952786,
    71329612474782464538636993009049310363619763878039,
    62184073572399794223406235393808339651327408011116,
    66627891981488087797941876876144230030984490851411,
    60661826293682836764744779239180335110989069790714,
    85786944089552990653640447425576083659976645795096,
    66024396409905389607120198219976047599490197230297,
    64913982680032973156037120041377903785566085089252,
    16730939319872750275468906903707539413042652315011,
    94809377245048795150954100921645863754710598436791,
    78639167021187492431995700641917969777599028300699,
    15368713711936614952811305876380278410754449733078,
    40789923115535562561142322423255033685442488917353,
    44889911501440648020369068063960672322193204149535,
    41503128880339536053299340368006977710650566631954,
    81234880673210146739058568557934581403627822703280,
    82616570773948327592232845941706525094512325230608,
    22918802058777319719839450180888072429661980811197,
    77158542502016545090413245809786882778948721859617,
    72107838435069186155435662884062257473692284509516,
    20849603980134001723930671666823555245252804609722,
    53503534226472524250874054075591789781264330331690
];
var largeSum = function(numArr, num) {
    // I'll convert numArr into an array of numbers and then reduce it as 'sumM'.
    var sumM = numArr.reduce(function(a, b) { return a + b; });
    return Number(sumM.toString().slice(0, num));
    // this outputs 9 digits (but 10 characters) because this number is huge and espressed as an exponential.
};
// console.log(largeSum(lottANums, 10)); // 5.53737623 * 10 ^ 51
console.log();


console.log(' ===== 14: LONGEST COLLATZ SEQUENCE  ===== ');
//-----------------------------------------------------------------------------+
// Longest Collatz sequence                                                    +
// Problem 14                                                                  +
// The following iterative sequence is defined for the set of positive integers:
//                                                                             +
// n → n/2 (n is even)                                                        +
// n → 3n + 1 (n is odd)                                                      +
//                                                                             +
// Using the rule above and starting with 13, we generate the following        +
// sequence:                                                                   +
//                                                                             +
// 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1                           +  
// It can be seen that this sequence (starting at 13 and finishing at 1)       +
// contains 10 terms. Although it has not been proved yet (Collatz Problem),   +
// it is thought that all starting numbers finish at 1.                        +
//                                                                             +
// Which starting number, under one million, produces the longest chain?       +
//                                                                             +
// NOTE: Once the chain starts the terms are allowed to go above one million.  +
//-----------------------------------------------------------------------------+
var collatzSequence = function(num) {
        // I will push each number in the sequence to the result array, and then return that when the function is called.
        var result = [];
        var newNum = num
        while (newNum !== 1) {
            if (newNum % 2 === 0) {
                result.push(newNum);
                newNum = newNum / 2;
            } else {
                result.push(newNum);
                newNum = 3 * newNum + 1;
            }
        }
        result.push(1);
        return result;
    }
    //----------------------------------------------------------------------
var longestCollatzSequence = function(startNum) {
    // I will create a helper function named collatzSequence to help with this solution. I will then iterate from 1 up to but not including startNum, which is 1000000 in this problem.
    var longestChain = 0;
    var numLongestChain = null;
    for (var i = 1; i < startNum; i++) {
        var colLength = collatzSequence(i).length;
        if (colLength > longestChain) {
            longestChain = colLength;
            numLongestChain = i;
        }
    }
    return numLongestChain;
};
// console.log(longestCollatzSequence(1000000)); // 837799
console.log();


console.log(' ===== 15: LATTICE PATHS ===== ');
//-----------------------------------------------------------------------------+
// Lattice paths                                                               +
// Problem 15                                                                  +
// Starting in the top left corner of a 2×2 grid, and only being able to move  +
// to the right and down, there are exactly 6 routes to the bottom right corner:
// right,right,down,down;  right,down,right,down;  right,down,down,right;      +
// down,right,right,down;  down,right,down,right;  down,down,right,right;      +
//                                                                             +
// How many such routes are there through a 20×20 grid?                        +
//-----------------------------------------------------------------------------+
var factorial = function(num) {
    var result = 1;
    for (var i = 1; i <= num; i++) {
        result *= i;
    }
    return result;
};
//----------------------------------------------------------------------
var combination = function(num1, num2) {
    return (factorial(num1) / (factorial(num2) * (factorial(num1 - num2))));
};
//----------------------------------------------------------------------
var latticePaths = function(i, j) {
    // For the 2 x 2 grid, we needed 2 steps right (2R) + 2 steps down (2D) complete any route. Hence in an n x m grid, a total of nR + mD steps would be required to complete any route. Using combinations (ignoring order), there would be nCr ways to complete the route. I will create combination and factorial helper functions to help with this solution. 
    return combination((i + j), j);
};
// console.log(latticePaths(20, 20)); // 137846528820
console.log();


console.log(' ===== 16: POWER DIGIT SUM ===== ');
//-----------------------------------------------------------------------------+
// Power digit sum                                                             +
// Problem 16                                                                  +
// 2 ** 15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.        +
//                                                                             +
// What is the sum of the digits of the number 2 ** 1000?                      +
//-----------------------------------------------------------------------------+
var powerDigitSum = function(num, power) {
    var numArray = (Math.pow(num, power)).toString().split('').map(function(a) {
        return Number(a);
    });
    return numArray.reduce(function(a, b) { return a + b; });
};
// console.log(powerDigitSum(2, 1000)); // my numArr is expressed as an exponential, and I am not sure how to obtain all the digits from the number. i tried splitting and selecting only numerical digits but my computer outputs a limited number of digits.
console.log();


console.log(' ===== 17: NUMBER LETTER COUNTS ===== ');
//-----------------------------------------------------------------------------+
// Number letter counts                                                        +
// Problem 17                                                                  +
// If the numbers 1 to 5 are written out in words: one, two, three, four, five,+
// then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.                +
//                                                                             +
// If all the numbers from 1 to 1000 (one thousand) inclusive were written out +
// in words, how many letters would be used?                                   +
//                                                                             +
//                                                                             +
// NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and   +
// forty-two) contains 23 letters and 115 (one hundred and fifteen) contains   +
// 20 letters. The use of "and" when writing out numbers is in compliance      +
// with British usage.                                                         +
//-----------------------------------------------------------------------------+
var numHashOnes = { 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 10: 'ten' };
var numHashTeens = { 11: 'eleven', 12: 'twelve', 13: 'thirteen', 14: 'fourteen', 15: 'fifteen', 16: 'sixteen', 17: 'seventeen', 18: 'eighteen', 19: 'nineteen', 20: 'twenty' };
var numHashTens = { 10: 'ten', 20: 'twenty', 30: 'thirty', 40: 'fourty', 50: 'fifty', 60: 'sixty', 70: 'seventy', 80: 'eighty', 90: 'ninety' };
var numHashHundreds = { 100: 'one hundred', 200: 'two hundred', 300: 'three hundred', 400: 'four hundred', 500: 'five hundred', 600: 'six hundred', 700: 'seven hundred', 800: 'eight hundred', 900: 'nine hundred' };
var numberLetterCounts = function(num) {

    var result = '';

    for (var i = 1; i <= num; i++) {
        if (i <= 10) {
            result += numHashOnes[i];
        } else if (i < 20) {
            result += numHashTeens[i];
        } else if (i < 100) {
            if (i % 10 === 0) {
                result += numHashTens[i];
            } else {
                var strNum = String(i);
                result += numHashTens[Number(strNum[0] + '0')] + ' ' + numHashOnes[Number(strNum[1])];
            }
        } else if (i < 1000 && i % 100 === 0) {
            var strNum = String(i);
            result += numHashHundreds[Number(strNum[0] + '00')];
        } else if (i < 1000) {
            var strNum = String(i);
            result += numHashHundreds[Number(strNum[0] + '00')] + ' and ' + numberLetterCounts(Number(strNum[1] + strNum[2]));
        }
    }

    return result.replace(/\s/g, '').length;
};
// console.log(numberLetterCounts(1000)); // 15930 instead of an expected value of 21124 from Project Euler.
console.log();


console.log(' ===== 18: MAXIMUM PATH SUM I ===== ');
//-----------------------------------------------------------------------------+
// Maximum path sum I                                                          +
// Problem 18                                                                  +
// By starting at the top of the triangle below and moving to adjacent numbers +
// on the row below, the maximum total from top to bottom is 23.               +
//                                                                             +
//    3                                                                        +
//   7 4                                                                       +
//  2 4 6                                                                      +
// 8 5 9 3                                                                     +
//                                                                             +
// That is, 3 + 7 + 4 + 9 = 23.                                                +
//                                                                             +
// Find the maximum total from top to bottom of the triangle below:            +
//                                                                             +
//               75                                                            +
//              95 64                                                          +
//             17 47 82                                                        +
//            18 35 87 10                                                      +
//           20 04 82 47 65                                                    +
//          19 01 23 75 03 34                                                  +
//         88 02 77 73 07 63 67                                                +
//        99 65 04 28 06 16 70 92                                              +
//       41 41 26 56 83 40 80 70 33                                            +
//      41 48 72 33 47 32 37 16 94 29                                          +
//     53 71 44 65 25 43 91 52 97 51 14                                        +
//    70 11 33 28 77 73 17 78 39 68 17 57                                      +
//   91 71 52 38 17 14 91 43 58 50 27 29 48                                    +
//  63 66 04 68 89 53 67 30 73 16 69 87 40 31                                  +
// 04 62 98 27 23 09 70 98 73 93 38 53 60 04 23                                +
//                                                                             +
// NOTE: As there are only 16384 routes, it is possible to solve this          +
// problem by trying every route. However, Problem 67, is the same challenge   +
// with a triangle containing one-hundred rows; it cannot be solved by brute   +
// force, and requires a clever method! ;o)                                    +
//-----------------------------------------------------------------------------+
var pyramidArr = [
    [75],
    [95, 64],
    [17, 47, 82],
    [18, 35, 87, 10],
    [20, 04, 82, 47, 65],
    [19, 01, 23, 75, 03, 34],
    [88, 02, 77, 73, 07, 63, 67],
    [99, 65, 04, 28, 06, 16, 70, 92],
    [41, 41, 26, 56, 83, 40, 80, 70, 33],
    [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
    [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
    [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
    [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
    [63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
    [04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23]
];
var maxPathSumI = function(arr) {
    //I first converted triangle into an array of arrays named pyramidArr.
    // I will add the first number at the apex of the pyramid to result to start the iteration, and make that index my main index. After that I will compare the index of the next array that matches the current array's index to the index + 1 of that same (next) array. the index with the bigger value becomes my next main index. I will continue this until i get to the bottom array.
    var result = 0;
    var bigIndx = 0;
    for (var i = 0; i < arr.length; i++) {
        if (i === 0) {
            result += arr[i][i];
        } else {
            (arr[i][bigIndx] > arr[i][bigIndx + 1]) ? (bigIndx = bigIndx) : (bigIndx += 1);
            result += arr[i][bigIndx];
        }
    }

    return result;
};
// console.log(maxPathSumI(pyramidArr)); // 1064 but I am expecting 1074 according to Project Euler. I foloowed the pyramid by hand to check for the answer and it did match my answer of 1064. I do not know what I may have done wrong and so I am sticking with my answer.
console.log();


console.log(' ===== 19: COUNTING SUNDAYS ===== ');
//-----------------------------------------------------------------------------+
// Counting Sundays                                                            +
// Problem 19                                                                  +
// You are given the following information, but you may prefer to do some      +
// research for yourself.                                                      +
//                                                                             +
// 1 Jan 1900 was a Monday.                                                    +
// Thirty days has September,                                                  +
// April, June and November.                                                   +
// All the rest have thirty-one,                                               +
// Saving February alone,                                                      +
// Which has twenty-eight, rain or shine.                                      +
// And on leap years, twenty-nine.                                             +
// A leap year occurs on any year evenly divisible by 4, but not on a century  +
// unless it is divisible by 400.                                              +
// How many Sundays fell on the first of the month during the twentieth        +
// century (1 Jan 1901 to 31 Dec 2000)?                                        +
//-----------------------------------------------------------------------------+
var countingSundays = function(startDate, endDate) {
    // I tried using a non-Date but intuitive approach but it got convulated and too long a code. So I resorted to the Date approach.
    // 
    var nuDate = new Date();
    var result = 0;

    for (var i = startDate + 1; i <= endDate; i++) {
        for (var j = 0; j <= 11; j++) {
            nuDate.setFullYear(i, j, 1);
            if (nuDate.getDay() === 0) {
                result++;
            }
        }
    }
    return result;
};
// console.log(countingSundays(1900, 2000)); // 171
console.log();


console.log(' ===== 20: FACTORIAL DIGIT SUM ===== ');
//-----------------------------------------------------------------------------+
// Factorial digit sum                                                         +
// Problem 20                                                                  +
// n! means n × (n − 1) × ... × 3 × 2 × 1                                      +
//                                                                             +
// For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,                      +
// and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 =  +
// 27.                                                                         +
//                                                                             +
// Find the sum of the digits in the number 100!                               +
//-----------------------------------------------------------------------------+
var factorialDigitSum = function(num) {
    // I will be calling the factorial function from Prob 15 above.
    var numStr = String(factorial(num).toFixed()).replace('e', '').replace('.', '').replace('+', '');
    var numArr = numStr.split('').map(function(x) {
        return Number(x);
    });
    // the return value for factorialDigitSum(100) is too large a number to be output here without expressing it as an exponential. 'toFixed()' only pipes the first 20 digits into computing the 'reduce' function. I couldn't find an better a way to collect and pipe all the digits from 100! given the limitations of my computer.
    return numArr.reduce(function(a, b) { return a + b; });
};
// console.log(factorialDigitSum(100)); // 73, but I am expecting 648. But I think this is because my computer can only output a limited number of digits.
// console.log();
//------------------------------------------------------------------------------
var factorialDigitSum = function(num) {
    var result = 0;
    var answer = factorial(num);
    // I struggled a lot with this problem, not knowing how to obtain all the digits in 100! After moving on and returning a day later I still couldn't figure a way to solve it so I looked up this solution. i have included the source here:
    // http://stackoverflow.com/questions/18907458/javascript-doesnt-give-correct-integer-output-project-euler-20

    // I do get the logic of this solution but I didn't come up with it.
    while (answer > 10) {
        result += Math.floor(answer % 10);
        answer /= 10;
    }
    return result;
};
// console.log(factorialDigitSum(100)); // 650 instead of an expected solution of 648 according to Project Euler.
console.log();

console.log(' ===== 21: AMICABLE NUMBERS ===== ');
//-----------------------------------------------------------------------------+
// Amicable numbers                                                            +
// Problem 21                                                                  +
// Let d(n) be defined as the sum of proper divisors of n (numbers less than n +
// which divide evenly into n).                                                +
// If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair    +
// and each of a and b are called amicable numbers.                            +
//                                                                             +
// For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, +
// 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, +
// 71 and 142; so d(284) = 220.                                                +
//                                                                             +
// Evaluate the sum of all the amicable numbers under 10000.                   +
//-----------------------------------------------------------------------------+
var factorsOfNum = function(num) {
    var factArr = [];
    for (var i = 1; i < num; i++) {
        if (num % i === 0) {
            factArr.push(i);
        }
    }
    return factArr;
};
//----------------------------------------------------------------------
var amicableTwins = function(num1, num2) {
    if (!isPrime(num1) && !isPrime(num2)) {
        var uno = factorsOfNum(num1).reduce(function(a, b) { return a + b; });
        var dos = factorsOfNum(num2).reduce(function(a, b) { return a + b; });
        return (uno === num2 && dos === num1);
    } else {
        return false;
    }
};
//----------------------------------------------------------------------
var sumAmicableNumbersUnder = function(num) {
    var result = 0;
    // I will be writing the helper functions amicableTwins and factorsOfNum to help with this solution. And then I will iterate through a combination of numbers from 1 up to num, checking if any pair are amicable numbers. If they are then they would be added to result.
    for (var i = 1; i <= num; i++) {
        for (var j = i + 1; j < num; j++) {
            if (amicableTwins(i, j)) {
                result += (i + j);
            }
        }
    }

    return result;
};
// console.log(sumAmicableNumbersUnder(10000)); // 31626. This took 2178.453 seconds to run.
console.log();


console.log(' ===== 22: NAMES SCORES ===== ');
//-----------------------------------------------------------------------------+
// Names scores                                                                +
// Problem 22                                                                  +
// Using the names.txt (a 46K text file containing over five-thousand first    +
// names), begin by sorting it into alphabetical order. Then working out the   +
// alphabetical value for each name, multiply this value by its alphabetical   +
// position in the list to obtain a name score.                                +
//                                                                             +
// For example, when the list is sorted into alphabetical order, COLIN, which  +
// is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So,      +
// COLIN would obtain a score of 938 × 53 = 49714.                             +
//                                                                             +
// What is the total of all the name scores in the file?                       +
//-----------------------------------------------------------------------------+
var totalNameScore = function(names) {
    // I have included the names.txt file in this zip.
    // I will start by sorting the names into a 'sortedNames' array.
    var sortedNames = names.sort();
    var totNameScore = 0;
    for (var i = 0; i < sortedNames.length; i++) {
        var nameScore = 0;
        for (j = 0; j < sortedNames[i].length; j++) {
            // And assuming all letters are uppercased; minus 64.
            nameScore += sortedNames[i][j].charCodeAt(0) - 64;
        }
        totNameScore += (nameScore * (i + 1));
    }
    return totNameScore;

};
// console.log(totalNameScore(names)); // 871198282
console.log();


console.log(' ===== 23: NON-ABUNDANT SUMS ===== ');
//-----------------------------------------------------------------------------+
// Non-abundant sums                                                           +
// Problem 23                                                                  +
// A perfect number is a number for which the sum of its proper divisors is    +
// exactly equal to the number. For example, the sum of the proper divisors    +
// of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect    +
//  number.                                                                    +
//                                                                             +
// A number n is called deficient if the sum of its proper divisors is less    +
// than n and it is called abundant if this sum exceeds n.                     +

// As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the          +
// smallest number that can be written as the sum of two abundant numbers is   +
// 24. By mathematical analysis, it can be shown that all integers greater     +
// than 28123 can be written as the sum of two abundant numbers. However,      +
// this upper limit cannot be reduced any further by analysis even though it   +
// is known that the greatest number that cannot be expressed as the sum of    +
// two abundant numbers is less than this limit.                               +
//                                                                             +
// Find the sum of all the positive integers which cannot be written as the    +
// sum of two abundant numbers.                                                +
//-----------------------------------------------------------------------------+
var abundantNum = function(num) {
    return factorsOfNum(num).reduce(function(a, b) { return a + b; }) > num;
};
//----------------------------------------------------------------------
var uniqVals = function(a) {
    return Array.from(new Set(a));
};
//----------------------------------------------------------------------
var nonAbundantSums = function(numLimit) {
    var abundantNumArr = [];
    var permTwoSumArr = [];
    var notPermTwoSumArr = [];
    // I am starting my iteration from 2 because the 'reduce' function called in 'abundantNum' requires more than one entry; but 1 only itself as a factor. This doesnt affect the result though, because 1 isn't an abundant number anyway.
    for (var i = 2; i < numLimit; i++) {
        if (abundantNum(i)) {
            abundantNumArr.push(i);
        }
    }
    // I will then create an array of the permutation sums of all entries in abundantNumArr
    for (var x = 0; x < abundantNumArr.length; x++) {
        for (var y = 0; y < abundantNumArr.length; y++) {
            permTwoSumArr.push(abundantNumArr[x] + abundantNumArr[y]);
        }
    }
    // I will eliminate duplicates from permTwoSumArr with the uniqVals function below
    permTwoSumArr = uniqVals(permTwoSumArr);
    // I will then check for all numbers from 1 up to, but not including numLimit that cannot be written as a sum of two abundant numbers and store them in notPermTwoSumArr
    for (var k = 1; k < numLimit; k++) {
        if (!permTwoSumArr.includes(k)) {
            notPermTwoSumArr.push(k);
        }
    }

    return notPermTwoSumArr.reduce(function(a, b) { return a + b; });
};
// console.log(nonAbundantSums(28123)); // 4179871
console.log();


console.log(' ===== 24: LEXICOGRAPHIC PERMUTATIONS ===== ');
//-----------------------------------------------------------------------------+
// Lexicographic permutations                                                  +
// Problem 24                                                                  +
// A permutation is an ordered arrangement of objects. For example, 3124 is    +
// one possible permutation of the digits 1, 2, 3 and 4. If all of the         +
// permutations are listed numerically or alphabetically, we call it           +
// lexicographic order. The lexicographic permutations of 0, 1 and 2 are:      +
//                                                                             +
// 012   021   102   120   201   210                                           +
//                                                                             +
// What is the millionth lexicographic permutation of the digits 0, 1, 2, 3,   +
// 4, 5, 6, 7, 8 and 9?                                                        +
//-----------------------------------------------------------------------------+
var givenArr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
var lexicographicPermutation = function(arr, indx) {
    // I will convert the digits into an array of striungs
    var numStr = arr.map(function(a) { return a.toString(); });
    var strLength = numStr.length;
    var permutatedArr = [];
    // I will loop through each combination of digits to create a permutation of the digits.
    for (var i = 0; i < strLength; i++) {
        for (var j = 0; j < strLength; j++) {
            for (var k = 0; k < strLength; k++) {
                for (var l = 0; l < strLength; l++) {
                    for (var m = 0; m < strLength; m++) {
                        for (var n = 0; n < strLength; n++) {
                            for (var o = 0; o < strLength; o++) {
                                for (var p = 0; p < strLength; p++) {
                                    for (var q = 0; q < strLength; q++) {
                                        for (var r = 0; r < strLength; r++) {
                                            // And then I will manually permutate through all the numbers and pushing them into the permutatedArr array in an 'increasing' order, without the need to sort the array later.
                                            var ii = (i !== j && i !== k && i !== l && i !== m && i !== n && i !== o && i !== p && i !== q && i !== r);
                                            var jj = (j !== k && j !== l && j !== m && j !== n && j !== o && j !== p && j !== q && j !== r);
                                            var kk = (k !== l && k !== m && k !== n && k !== o && k !== p && k !== q && k !== r);
                                            var ll = (l !== m && l !== n && l !== o && l !== p && l !== q && l !== r);
                                            var mm = (m !== n && m !== o && m !== p && m !== q && m !== r);
                                            var nn = (n !== o && n !== p && n !== q && n !== r);
                                            var oo = (o !== p && o !== q && o !== r);
                                            var pp = (p !== q && p !== r);
                                            var qq = (q !== r);
                                            // Here, I ommit any entry that has duplicate digits within the entry, pushing the filtered entries into permutatedArr.
                                            if (ii && jj && kk && ll && mm && nn && oo && pp && qq) {
                                                permutatedArr.push(numStr[i] + numStr[j] + numStr[k] + numStr[l] + numStr[m] + numStr[n] + numStr[o] + numStr[p] + numStr[q] + numStr[r]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return permutatedArr[indx];
};
// console.log(lexicographicPermutation(givenArr, 999999)); // 2783915460
console.log();

console.log(' ===== 25: 1000-DIGIT FIBONACCI NUMBER ===== ');
//-----------------------------------------------------------------------------+
// 1000-digit Fibonacci number                                                 +
// Problem 25                                                                  +
// The Fibonacci sequence is defined by the recurrence relation:               +
//                                                                             +
// Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.                                  +
// Hence the first 12 terms will be:                                           +
//                                                                             +
// F1 = 1                                                                      +
// F2 = 1                                                                      +
// F3 = 2                                                                      +
// F4 = 3                                                                      +
// F5 = 5                                                                      +
// F6 = 8                                                                      +
// F7 = 13                                                                     +
// F8 = 21                                                                     +
// F9 = 34                                                                     +
// F10 = 55                                                                    +
// F11 = 89                                                                    +
// F12 = 144                                                                   +
// The 12th term, F12, is the first term to contain three digits.              +
//                                                                             +
// What is the index of the first term in the Fibonacci sequence to contain    +
// 1000 digits?                                                                +
//-----------------------------------------------------------------------------+
var firstNthDigitFibonacci = function(reqDigits) {
    var secondToLastFib = 1;
    var lastFib = 1;
    var indexOfLastFib = 1;

    while (String(lastFib).length <= reqDigits) {
        var c = secondToLastFib + lastFib;
        secondToLastFib = lastFib;
        lastFib = c;
        indexOfLastFib += 1;
    }

    return indexOfLastFib;
};
// console.log(firstNthDigitFibonacci(1000)); // 4782 
console.log();


console.log(' ===== 26: RECIPROCAL CYCLES ===== ');
//-----------------------------------------------------------------------------+
// Reciprocal cycles                                                           +
// Problem 26                                                                  +
// A unit fraction contains 1 in the numerator. The decimal representation of  +
// the unit fractions with denominators 2 to 10 are given:                     +
//                                                                             +
// 1/2	= 	0.5                                                                +
// 1/3	= 	0.(3)                                                              +
// 1/4	= 	0.25                                                               +
// 1/5	= 	0.2                                                                +
// 1/6	= 	0.1(6)                                                             +
// 1/7	= 	0.(142857)                                                         +
// 1/8	= 	0.125                                                              +
// 1/9	= 	0.(1)                                                              +
// 1/10	= 	0.1                                                                +
// Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can   +
// be seen that 1/7 has a 6-digit recurring cycle.                             +
//                                                                             +
// Find the value of d < 1000 for which 1/d contains the longest recurring     +
// cycle in its decimal fraction part.                                         +
//-----------------------------------------------------------------------------+
var reciprocalCycles = function(limit) {
    result = 'oooops!';
    var trueCounter = 0;
    for (var i = 2; i < limit; i++) {
        var arr = ['dummy element'];
        var remainder = 1;
        var j = 1; // 'j' will serve as a pseudo-counter which will be used to obtain the length of the repeating decimal numbers within each 1/d iteration. 
        //----------------------------------------------------------------------
        // Before the start of the while loop there is only one element - dummy element - in arr so the loop will start, and assign j++ to the index in arr indicated by the value of remainder. 
        while (arr[remainder] === undefined) {
            arr[remainder] = j++;
            // I will then detrmine the next remainder by multiplying the previous remainder by 10 and then taken that value mod i, assigning the output to remainder.
            remainder = (remainder * 10) % i;
            var localCounter = j - arr[remainder]; // gives the length of the repeating decimals
        }
        if (remainder !== 0 && localCounter > trueCounter) {
            // when an individual iteration terminates / if there arent any further remainders, and the localCounter is greater than the trueCounter, make localCounter trueCounter.
            trueCounter = localCounter;
            result = i;
        }
    }
    return result;
};
// console.log(reciprocalCycles(1000)); // 983 
console.log();


console.log(' ===== 27: QUADRATIC PRIMES ===== ');
//-----------------------------------------------------------------------------+
// Quadratic primes                                                            +
// Problem 27                                                                  +
// Euler discovered the remarkable quadratic formula:                          +
//                                                                             +
// n ** 2 + n + 41                                                             +
// It turns out that the formula will produce 40 primes for the consecutive    +
// integer values 0 ≤ n ≤ 39. However, when n = 40, 40 ** 2 + 40 + 41 =        +
// 40 (40+1) + 41, is divisible by 41, and certainly when n = 41,              +
// 41 ** 2 + 41 + 41 is clearly divisible by 41.                               +
//                                                                             +
// The incredible formula n ** 2 − 79 * n + 1601 was discovered, which         +
// produces 80 primes for the consecutive values 0 ≤ n ≤ 79. The product of    +
// the coefficients, −79 and 1601, is −126479.                                 +
//                                                                             +
// Considering quadratics of the form:                                         +
//                                                                             +
// n ** 2 + a * n + b, where |a| < 1000 and |b| ≤ 1000                         +
//                                                                             +
// where |n| is the modulus/absolute value of n                                +
// e.g. |11| =11 and |−4| = 4                                                  +
// Find the product of the coefficients, a and b, for the quadratic expression +
// that produces the maximum number of primes for consecutive values of n,     +
// starting with n = 0.                                                        +
//-----------------------------------------------------------------------------+
var quadraticPrimes = function(num) {
    // I will be calling back on the isPrime function from problem 3 for this problem.
    var aMax = 0;
    var bMax = 0;
    var nMax = 0;
    // Then i will loop through the range of numbers given and check for prime counts to determine which 'a' and 'b' combination yields the most primes.
    for (var a = -num; a <= num; a++) {
        for (var b = -num; b <= num; b++) {
            var n = 0;
            while (isPrime(Math.abs(n * n + a * n + b))) {
                n++;
            }

            if (n > nMax) {
                aMax = a;
                bMax = b;
                nMax = n;
            }
        }
    }

    return aMax * bMax;
};
// console.log(quadraticPrimes(1000)); // -59231
console.log();


console.log(' ===== 28: NUMBR SPIRAL DIAGONALS ===== ');
//-----------------------------------------------------------------------------+
// Number spiral diagonals                                                     +
// Problem 28                                                                  +
// Starting with the number 1 and moving to the right in a clockwise direction +
//  a 5 by 5 spiral is formed as follows:                                      +
//                                                                             +
// 21 22 23 24 25                                                              +
// 20  7  8  9 10                                                              +
// 19  6  1  2 11                                                              +
// 18  5  4  3 12                                                              +
// 17 16 15 14 13                                                              +
//                                                                             +
// It can be verified that the sum of the numbers on the diagonals is 101.     +
//                                                                             +
// What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral    +
//  formed in the same way?                                                    +
//-----------------------------------------------------------------------------+
var spiralDiagonals = function(num) {
    // I spent a whole night and full morning trying to solve this problem but couldn't figure a way other than drawing out the spiral. I then decided to google up solutions to the problem. my first hit was from 'https://jaysoo.ca/2008/11/10/project-euler-problem-28/' and the only information I borrowed from there was:

    // 'The first thing to notice is that you don’t have to actually construct the spiral in order to solve this problem. In an nxn spiral, the values of the four corners are as follows:
    // top-right: n^2 top-left: n^2 - n + 1 bottom-left: n^2 - 2n + 2 bottom-right: n^2 - 3n + 3
    // Adding all that up yields 4n^2 -6n + 6.
    // At this point you can loop through from 3 to 1001 (in increments of 2) and add up the results. Just make sure you add a 1 to the results for the base case. :)'
    // After reading through, understanding and agreeing with OP's reasoning I produced the follwoing solution in under 5 minutes.
    //----------------------------------------------------------------------
    // to ensure that the starting '1' in an odd numbered spiral diagonal is added, I will check whther or not the spiral is odd or even, and then start my result value as either zero or 1.
    if (num % 2 == 1) {
        var result = 1;
    } else {
        var result = 0;
    }
    // Then I will iterate in steps of two as explained above.
    while (num > 1) {
        result += 4 * (num ** 2) - (6 * num) + 6;
        num -= 2;
    }

    return result;
};
// console.log(spiralDiagonals(1001)); // 669171001
console.log();


console.log(' ===== 29: DISTINCT POWERS ===== ');
//-----------------------------------------------------------------------------+
// Distinct powers                                                             +
// Problem 29                                                                  +
// Consider all integer combinations of a ** b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:    +
//                                                                             +
// 2 ** 2 = 4, 2 ** 3 = 8, 2 ** 4 = 16, 2 ** 5 = 32                            +
// 3 ** 2 = 9, 3 ** 3 = 27, 3 ** 4 = 81, 3 ** 5 = 243                          +
// 4 ** 2 = 16, 4 ** 3 = 64, 4 ** 4 = 256, 4 ** 5 = 1024                       +
// 5 ** 2 = 25, 5 ** 3 = 125, 5 ** 4 = 625, 5 ** 5 = 3125                      +
// If they are then placed in numerical order, with any repeats removed, we    +
// get the following sequence of 15 distinct terms:                            +
//                                                                             +
// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125             +
//                                                                             +
// How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 +
// and 2 ≤ b ≤ 100?                                                            +
//-----------------------------------------------------------------------------+
var distinctPowers = function(aRange, bRange) {
    var resultArr = [];
    // I will just loop through all numbers within the range, push the results into the resultArr, and then return the length of the resultArr.
    for (var a = 2; a <= aRange; a++) {
        for (var b = 2; b <= bRange; b++) {
            if (!resultArr.includes(a ** b)) {
                resultArr.push(a ** b);
            }
        }
    }

    return resultArr.length;
};
// console.log(distinctPowers(100, 100)); // 9183
console.log();


console.log(' ===== 30: DIGIT FIFTH POWERS ===== ');
//-----------------------------------------------------------------------------+
// Digit fifth powers                                                          +
// Problem 30                                                                  +
// Surprisingly there are only three numbers that can be written as the sum of +
// fourth powers of their digits:                                              +
//                                                                             +
// 1634 = 1 ** 4 + 6 ** 4 + 3 **4 + 4 ** 4                                     +
// 8208 = 8 ** 4 + 2 ** 4 + 0 ** 4 + 8 ** 4                                    +
// 9474 = 9 ** 4 + 4 ** 4 + 7 ** 4 + 4 ** 4                                    +
// As 1 = 1 ** 4 is not a sum it is not included.                              +
//                                                                             +
// The sum of these numbers is 1634 + 8208 + 9474 = 19316.                     +
//                                                                             +
// Find the sum of all the numbers that can be written as the sum of fifth     +
// powers of their digits.                                                     +
//-----------------------------------------------------------------------------+
var fifthPowerble = function(num) {
    var numArr = String(num).split('').map(function(a) { return Number(a); });
    var fifthPowers = numArr.map(function(a) { return a ** 5 });
    return num === fifthPowers.reduce(function(a, b) { return a + b; });
};
//----------------------------------------------------------------------
var digitFifthPowers = function(cutOffRange) {
    //the biggest fifth power (for i < 10) is 9 ** 5 = 59049 and the smalest fifth power (ignoring 1) is 2 ** 5 = 32. Hence I need to consider numbers between 32 and largest six-digit number (999,999) in order to be generous but still avoid looping indefinitely. Thus I will be setting my cutOffRange value to 999,999
    var result = 0;
    for (var i = 2; i <= cutOffRange; i++) {
        if (fifthPowerble(i)) {
            result += i;
        }
    }
    return result;
};
// console.log(digitFifthPowers(999999)); // 443839
console.log();



console.log();
//----------------------------------------------------------------------
console.log(' ===== END OF PAGE ===== ');
//----------------------------------------------------------------------
console.log();